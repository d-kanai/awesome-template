/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Awesome Template API
 * Awesome Template „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Çµ„Éº„Éì„Çπ„ÅÆ API „Éâ„Ç≠„É•„É°„É≥„Éà„Åß„Åô„ÄÇ
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  FindAllUsersResponse,
  FindUserByEmailResponse,
  FindUserByIdResponse,
  HealthStatusResponse,
  SignupRequest,
  SignupResponse,
  UpdateUserProfileRequest,
  UpdateUserProfileResponse
} from './model';

import { fetcher } from '../fetcher';
type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * ÊåáÂÆö„Åó„ÅüË≠òÂà•Â≠ê„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂèñÂæó„Åó„Åæ„Åô„ÄÇ
 * @summary ID „Åß„É¶„Éº„Ç∂„Éº„ÇíÂèñÂæó
 */
export type getUserByIdResponse200 = {
  data: FindUserByIdResponse
  status: 200
}

export type getUserByIdResponse400 = {
  data: void
  status: 400
}

export type getUserByIdResponse404 = {
  data: void
  status: 404
}
    
export type getUserByIdResponseSuccess = (getUserByIdResponse200) & {
  headers: Headers;
};
export type getUserByIdResponseError = (getUserByIdResponse400 | getUserByIdResponse404) & {
  headers: Headers;
};

export type getUserByIdResponse = (getUserByIdResponseSuccess | getUserByIdResponseError)

export const getGetUserByIdUrl = (id: string,) => {


  

  return `/users/${id}`
}

export const getUserById = async (id: string, options?: RequestInit): Promise<getUserByIdResponse> => {
  
  return fetcher<getUserByIdResponse>(getGetUserByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetUserByIdQueryKey = (id?: string,) => {
    return [
    `/users/${id}`
    ] as const;
    }

    
export const getGetUserByIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserById>>, TError = void | void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, request?: SecondParameter<typeof fetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) => getUserById(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>
export type GetUserByIdQueryError = void | void


export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = void | void>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = void | void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = void | void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ID „Åß„É¶„Éº„Ç∂„Éº„ÇíÂèñÂæó
 */

export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = void | void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Êó¢Â≠ò„É¶„Éº„Ç∂„Éº„ÅÆ„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ„Åæ„Åü„ÅØÊ∞èÂêç„ÇíÊõ¥Êñ∞„Åó„Åæ„Åô„ÄÇ
 * @summary „É¶„Éº„Ç∂„Éº„ÇíÊõ¥Êñ∞
 */
export type updateUserProfileResponse200 = {
  data: UpdateUserProfileResponse
  status: 200
}

export type updateUserProfileResponse400 = {
  data: void
  status: 400
}
    
export type updateUserProfileResponseSuccess = (updateUserProfileResponse200) & {
  headers: Headers;
};
export type updateUserProfileResponseError = (updateUserProfileResponse400) & {
  headers: Headers;
};

export type updateUserProfileResponse = (updateUserProfileResponseSuccess | updateUserProfileResponseError)

export const getUpdateUserProfileUrl = (id: string,) => {


  

  return `/users/${id}`
}

export const updateUserProfile = async (id: string,
    updateUserProfileRequest: UpdateUserProfileRequest, options?: RequestInit): Promise<updateUserProfileResponse> => {
  
  return fetcher<updateUserProfileResponse>(getUpdateUserProfileUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserProfileRequest,)
  }
);}




export const getUpdateUserProfileMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserProfile>>, TError,{id: string;data: UpdateUserProfileRequest}, TContext>, request?: SecondParameter<typeof fetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof updateUserProfile>>, TError,{id: string;data: UpdateUserProfileRequest}, TContext> => {

const mutationKey = ['updateUserProfile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserProfile>>, {id: string;data: UpdateUserProfileRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateUserProfile(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserProfileMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserProfile>>>
    export type UpdateUserProfileMutationBody = UpdateUserProfileRequest
    export type UpdateUserProfileMutationError = void

    /**
 * @summary „É¶„Éº„Ç∂„Éº„ÇíÊõ¥Êñ∞
 */
export const useUpdateUserProfile = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserProfile>>, TError,{id: string;data: UpdateUserProfileRequest}, TContext>, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUserProfile>>,
        TError,
        {id: string;data: UpdateUserProfileRequest},
        TContext
      > => {

      const mutationOptions = getUpdateUserProfileMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ÊåáÂÆö„Åó„ÅüË≠òÂà•Â≠ê„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§„Åó„Åæ„Åô„ÄÇ
 * @summary „É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§
 */
export type deleteUserResponse204 = {
  data: void
  status: 204
}

export type deleteUserResponse400 = {
  data: void
  status: 400
}

export type deleteUserResponse404 = {
  data: void
  status: 404
}
    
export type deleteUserResponseSuccess = (deleteUserResponse204) & {
  headers: Headers;
};
export type deleteUserResponseError = (deleteUserResponse400 | deleteUserResponse404) & {
  headers: Headers;
};

export type deleteUserResponse = (deleteUserResponseSuccess | deleteUserResponseError)

export const getDeleteUserUrl = (id: string,) => {


  

  return `/users/${id}`
}

export const deleteUser = async (id: string, options?: RequestInit): Promise<deleteUserResponse> => {
  
  return fetcher<deleteUserResponse>(getDeleteUserUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteUserMutationOptions = <TError = void | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof fetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteUser(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = void | void

    /**
 * @summary „É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§
 */
export const useDeleteUser = <TError = void | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Çã„Åô„Åπ„Å¶„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂèñÂæó„Åó„Åæ„Åô„ÄÇ
 * @summary „É¶„Éº„Ç∂„Éº‰∏ÄË¶ß„ÇíÂèñÂæó
 */
export type getAllUsersResponse200 = {
  data: FindAllUsersResponse
  status: 200
}
    
export type getAllUsersResponseSuccess = (getAllUsersResponse200) & {
  headers: Headers;
};
;

export type getAllUsersResponse = (getAllUsersResponseSuccess)

export const getGetAllUsersUrl = () => {


  

  return `/users`
}

export const getAllUsers = async ( options?: RequestInit): Promise<getAllUsersResponse> => {
  
  return fetcher<getAllUsersResponse>(getGetAllUsersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAllUsersQueryKey = () => {
    return [
    `/users`
    ] as const;
    }

    
export const getGetAllUsersQueryOptions = <TData = Awaited<ReturnType<typeof getAllUsers>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, request?: SecondParameter<typeof fetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllUsers>>> = ({ signal }) => getAllUsers({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getAllUsers>>>
export type GetAllUsersQueryError = unknown


export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllUsers>>,
          TError,
          Awaited<ReturnType<typeof getAllUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllUsers>>,
          TError,
          Awaited<ReturnType<typeof getAllUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary „É¶„Éº„Ç∂„Éº‰∏ÄË¶ß„ÇíÂèñÂæó
 */

export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ÊåáÂÆö„Åó„ÅüÊÉÖÂ†±„ÅßÊñ∞„Åó„ÅÑ„É¶„Éº„Ç∂„Éº„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ
 * @summary „É¶„Éº„Ç∂„Éº„ÇíÁôªÈå≤
 */
export type signupResponse201 = {
  data: SignupResponse
  status: 201
}

export type signupResponse400 = {
  data: void
  status: 400
}
    
export type signupResponseSuccess = (signupResponse201) & {
  headers: Headers;
};
export type signupResponseError = (signupResponse400) & {
  headers: Headers;
};

export type signupResponse = (signupResponseSuccess | signupResponseError)

export const getSignupUrl = () => {


  

  return `/users`
}

export const signup = async (signupRequest: SignupRequest, options?: RequestInit): Promise<signupResponse> => {
  
  return fetcher<signupResponse>(getSignupUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      signupRequest,)
  }
);}




export const getSignupMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError,{data: SignupRequest}, TContext>, request?: SecondParameter<typeof fetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError,{data: SignupRequest}, TContext> => {

const mutationKey = ['signup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signup>>, {data: SignupRequest}> = (props) => {
          const {data} = props ?? {};

          return  signup(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SignupMutationResult = NonNullable<Awaited<ReturnType<typeof signup>>>
    export type SignupMutationBody = SignupRequest
    export type SignupMutationError = void

    /**
 * @summary „É¶„Éº„Ç∂„Éº„ÇíÁôªÈå≤
 */
export const useSignup = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError,{data: SignupRequest}, TContext>, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof signup>>,
        TError,
        {data: SignupRequest},
        TContext
      > => {

      const mutationOptions = getSignupMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ÊåáÂÆö„Åó„Åü„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂèñÂæó„Åó„Åæ„Åô„ÄÇ
 * @summary „É°„Éº„É´„Ç¢„Éâ„É¨„Çπ„Åß„É¶„Éº„Ç∂„Éº„ÇíÂèñÂæó
 */
export type getUserByEmailResponse200 = {
  data: FindUserByEmailResponse
  status: 200
}

export type getUserByEmailResponse404 = {
  data: void
  status: 404
}
    
export type getUserByEmailResponseSuccess = (getUserByEmailResponse200) & {
  headers: Headers;
};
export type getUserByEmailResponseError = (getUserByEmailResponse404) & {
  headers: Headers;
};

export type getUserByEmailResponse = (getUserByEmailResponseSuccess | getUserByEmailResponseError)

export const getGetUserByEmailUrl = (email: string,) => {


  

  return `/users/email/${email}`
}

export const getUserByEmail = async (email: string, options?: RequestInit): Promise<getUserByEmailResponse> => {
  
  return fetcher<getUserByEmailResponse>(getGetUserByEmailUrl(email),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetUserByEmailQueryKey = (email?: string,) => {
    return [
    `/users/email/${email}`
    ] as const;
    }

    
export const getGetUserByEmailQueryOptions = <TData = Awaited<ReturnType<typeof getUserByEmail>>, TError = void>(email: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByEmail>>, TError, TData>>, request?: SecondParameter<typeof fetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByEmailQueryKey(email);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserByEmail>>> = ({ signal }) => getUserByEmail(email, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(email), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserByEmail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByEmailQueryResult = NonNullable<Awaited<ReturnType<typeof getUserByEmail>>>
export type GetUserByEmailQueryError = void


export function useGetUserByEmail<TData = Awaited<ReturnType<typeof getUserByEmail>>, TError = void>(
 email: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByEmail>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserByEmail>>,
          TError,
          Awaited<ReturnType<typeof getUserByEmail>>
        > , 'initialData'
      >, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserByEmail<TData = Awaited<ReturnType<typeof getUserByEmail>>, TError = void>(
 email: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByEmail>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserByEmail>>,
          TError,
          Awaited<ReturnType<typeof getUserByEmail>>
        > , 'initialData'
      >, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserByEmail<TData = Awaited<ReturnType<typeof getUserByEmail>>, TError = void>(
 email: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByEmail>>, TError, TData>>, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary „É°„Éº„É´„Ç¢„Éâ„É¨„Çπ„Åß„É¶„Éº„Ç∂„Éº„ÇíÂèñÂæó
 */

export function useGetUserByEmail<TData = Awaited<ReturnType<typeof getUserByEmail>>, TError = void>(
 email: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByEmail>>, TError, TData>>, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByEmailQueryOptions(email,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * „Çµ„Éº„Éì„Çπ„ÅÆÁèæÂú®„ÅÆÁä∂ÊÖã„ÇíËøî„Åó„Åæ„Åô„ÄÇ
 * @summary „Çµ„Éº„Éì„Çπ„ÅÆÁ®ºÂÉçÁä∂Ê≥Å
 */
export type healthResponse200 = {
  data: HealthStatusResponse
  status: 200
}
    
export type healthResponseSuccess = (healthResponse200) & {
  headers: Headers;
};
;

export type healthResponse = (healthResponseSuccess)

export const getHealthUrl = () => {


  

  return `/health`
}

export const health = async ( options?: RequestInit): Promise<healthResponse> => {
  
  return fetcher<healthResponse>(getHealthUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getHealthQueryKey = () => {
    return [
    `/health`
    ] as const;
    }

    
export const getHealthQueryOptions = <TData = Awaited<ReturnType<typeof health>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>>, request?: SecondParameter<typeof fetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof health>>> = ({ signal }) => health({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthQueryResult = NonNullable<Awaited<ReturnType<typeof health>>>
export type HealthQueryError = unknown


export function useHealth<TData = Awaited<ReturnType<typeof health>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof health>>,
          TError,
          Awaited<ReturnType<typeof health>>
        > , 'initialData'
      >, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealth<TData = Awaited<ReturnType<typeof health>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof health>>,
          TError,
          Awaited<ReturnType<typeof health>>
        > , 'initialData'
      >, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealth<TData = Awaited<ReturnType<typeof health>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>>, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary „Çµ„Éº„Éì„Çπ„ÅÆÁ®ºÂÉçÁä∂Ê≥Å
 */

export function useHealth<TData = Awaited<ReturnType<typeof health>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>>, request?: SecondParameter<typeof fetcher>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
